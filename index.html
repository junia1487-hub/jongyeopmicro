<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Halftone Master v6.5 - Final Perfect</title>
  <style>
    :root{color-scheme:dark;}
    body{margin:0;font-family:sans-serif;background:#111;color:#eee;height:100vh;overflow:hidden;}
    .app { display: flex; height: 100%; }
    
    .viewport { 
        flex: 1; 
        background-color: #222;
        /* 투명도 확인용 체크무늬 배경 */
        background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
        background-size: 20px 20px;
        display: flex; justify-content: center; align-items: center; 
        padding: 20px;
    }
    canvas#mainCanvas {
        /* 캔버스 배경을 투명하게 해서 뒤쪽 체크무늬가 보이게 함 */
        background: transparent; 
        box-shadow: 0 0 30px rgba(0,0,0,0.8);
        max-width: 100%; max-height: 100%; object-fit: contain;
    }

    .controls { width: 380px; background: #181818; border-left: 1px solid #333; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
    
    .panel-box { background: #222; padding: 15px; border-radius: 8px; border: 1px solid #333; }
    h2 { margin: 0 0 10px 0; font-size: 14px; color: #888; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px; }
    
    /* UI 컨트롤 스타일 개선 */
    .control-group { margin-bottom: 8px; }
    .control-label { display: flex; justify-content: space-between; font-size: 12px; color: #bbb; margin-bottom: 4px; }
    .input-row { display: flex; align-items: center; gap: 8px; }
    
    /* 슬라이더 */
    input[type=range] { flex: 1; margin: 0; cursor: pointer; }
    
    /* 수치 입력창 */
    input[type=number] { 
        width: 45px; background: #333; border: 1px solid #555; color: #fff; 
        border-radius: 4px; padding: 4px 2px; font-size: 12px; text-align: center; 
    }
    input[type=number]:focus { border-color: #4ade80; outline: none; }

    select, button { width: 100%; margin-bottom: 10px; box-sizing: border-box; }
    button { padding: 12px; background: #333; border: 1px solid #555; color: white; cursor: pointer; border-radius: 4px; font-weight: bold; }
    button:hover { background: #444; border-color: #777; }
    button.primary { background: #eee; color: black; }
    
    .mask-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top:10px; }
    .mask-slot { 
        aspect-ratio: 1; border: 1px dashed #555; position: relative; 
        display: flex; align-items: center; justify-content: center; 
        font-size: 10px; background: #000; cursor: pointer; overflow: hidden;
        color: #888;
    }
    .mask-slot img { width: 100%; height: 100%; object-fit: contain; }
    .mask-slot input { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
    .mask-slot.active { border: 2px solid #4ade80; color: transparent; }

    #loading { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:999; display:none; justify-content:center; align-items:center; flex-direction:column; }
</style>
</head>
<body>

<div id="loading"><div style="color:white; font-size:14px;">최적화 처리중...</div></div>

<div class="app">
    <div class="viewport">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div class="controls">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h1 style="font-size:18px; color:white; margin:0;">Halftone v6.5</h1>
            <span style="font-size:11px; color:#4ade80;">Final + UI/Alpha</span>
        </div>

        <div class="panel-box">
            <h2>1. 원본 이미지</h2>
            <input type="file" id="inpImg" accept="image/*" />
            <div style="font-size:11px; color:#888; margin-top:5px;">* 투명 PNG 지원 (빈 공간 유지)</div>
        </div>

        <div class="panel-box">
            <h2>2. 패턴 설정</h2>
            
            <div class="control-group">
                <div class="control-label">셀 크기 (밀도)</div>
                <div class="input-row">
                    <input type="range" id="rnCell" min="10" max="150" value="30">
                    <input type="number" id="numCell" min="10" max="150" value="30">
                </div>
            </div>

            <div style="display:flex; gap:10px;">
                <div style="flex:1" class="control-group">
                    <div class="control-label">최소 %</div>
                    <div class="input-row">
                        <input type="range" id="rnMin" min="0" max="90" value="10">
                        <input type="number" id="numMin" min="0" max="90" value="10">
                    </div>
                </div>
                <div style="flex:1" class="control-group">
                    <div class="control-label">최대 %</div>
                    <div class="input-row">
                        <input type="range" id="rnMax" min="10" max="100" value="90">
                        <input type="number" id="numMax" min="10" max="100" value="90">
                    </div>
                </div>
            </div>

            <div style="display:flex; gap:10px;">
                <div style="flex:1" class="control-group">
                    <div class="control-label">대비</div>
                    <div class="input-row">
                        <input type="range" id="rnCon" min="0" max="200" value="100">
                        <input type="number" id="numCon" min="0" max="200" value="100">
                    </div>
                </div>
                <div style="flex:1" class="control-group">
                    <div class="control-label">감마</div>
                    <div class="input-row">
                        <input type="range" id="rnGam" min="50" max="250" value="100">
                        <input type="number" id="numGam" min="50" max="250" value="100">
                    </div>
                </div>
            </div>
        </div>

        <div class="panel-box">
            <h2>3. 응용 마스크 (S/E/O/C)</h2>
            <div class="mask-grid">
                <div class="mask-slot" id="slotS">S<input type="file" onchange="loadMask('S', this)"></div>
                <div class="mask-slot" id="slotE">E<input type="file" onchange="loadMask('E', this)"></div>
                <div class="mask-slot" id="slotO">O<input type="file" onchange="loadMask('O', this)"></div>
                <div class="mask-slot" id="slotC">C<input type="file" onchange="loadMask('C', this)"></div>
            </div>

            <div style="margin-top:15px; padding-top:10px; border-top:1px solid #333;">
                <label>모드 선택</label>
                <select id="selMode">
                    <option value="1">응용 모드 (S/E/O/C)</option>
                    <option value="0">기본 모드 (사각형)</option>
                </select>

                <div style="display:flex; gap:5px; margin-top:5px;">
                    <div style="flex:1"><label>순서</label><select id="selOrd"><option value="0">S-E-O-C</option><option value="1" selected>S-E-C-O</option></select></div>
                </div>
                
                <div style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                    <div class="control-label">톤 구간 설정 (T1, T2, T3)</div>
                    <div class="control-group">
                        <div class="input-row">
                            <span style="font-size:10px; width:15px;">T1</span>
                            <input type="range" id="t1" max="100" value="25">
                            <input type="number" id="numT1" max="100" value="25">
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="input-row">
                            <span style="font-size:10px; width:15px;">T2</span>
                            <input type="range" id="t2" max="100" value="50">
                            <input type="number" id="numT2" max="100" value="50">
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="input-row">
                            <span style="font-size:10px; width:15px;">T3</span>
                            <input type="range" id="t3" max="100" value="75">
                            <input type="number" id="numT3" max="100" value="75">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel-box">
            <h2>4. 내보내기</h2>
            <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
                <input type="checkbox" id="chkFlip"> SVG 상하반전 (일러스트용)
            </label>
            <button class="primary" id="btnSvg">SVG 저장</button>
            <button id="btnPng" style="margin-top:5px;">PNG 저장</button>
        </div>
    </div>
</div>

<script>
/**
 * Halftone Master v6.5
 * Base: v6.4 (Greedy Optimization)
 * New: 
 * 1. Full UI sync (Slider <-> Number Input)
 * 2. Transparent PNG support (Skip Alpha < 10)
 */
const $ = id => document.getElementById(id);
const cvs = $("mainCanvas");
const ctx = cvs.getContext("2d", { willReadFrequently: true });

// UI 동기화 함수
function bindInput(rangeId, numId, callback) {
    const range = $(rangeId);
    const num = $(numId);
    range.oninput = () => { num.value = range.value; if(callback) callback(); };
    num.oninput = () => { range.value = num.value; if(callback) callback(); };
}

const state = {
    srcImg: null, 
    masks: { S:null, E:null, O:null, C:null },
    maskData: { S:null, E:null, O:null, C:null } 
};

function convertToWhiteMask(img) {
    const s = 128; 
    const c = document.createElement("canvas"); c.width = s; c.height = s;
    const cx = c.getContext("2d");
    cx.drawImage(img, 0, 0, s, s);
    cx.globalCompositeOperation = 'source-in';
    cx.fillStyle = 'white';
    cx.fillRect(0, 0, s, s);
    const whiteImg = new Image();
    whiteImg.src = c.toDataURL();
    return new Promise(resolve => { whiteImg.onload = () => resolve(whiteImg); });
}

function analyzeMask(img) {
    const s = 128; 
    const c = document.createElement("canvas"); c.width = s; c.height = s;
    const cx = c.getContext("2d");
    cx.drawImage(img, 0, 0, s, s);
    return cx.getImageData(0, 0, s, s);
}

async function createDefaultMask(char) {
    const c = document.createElement("canvas"); c.width = 128; c.height = 128;
    const cx = c.getContext("2d");
    cx.fillStyle = "transparent"; cx.fillRect(0,0,128,128); 
    cx.fillStyle = "white"; cx.font = "bold 100px sans-serif";
    cx.textAlign = "center"; cx.textBaseline = "middle";
    cx.fillText(char, 64, 64);
    
    const img = new Image();
    img.src = c.toDataURL();
    return new Promise(resolve => {
        img.onload = () => {
            state.masks[char] = img;
            state.maskData[char] = analyzeMask(img);
            resolve();
        };
    });
}

(async () => {
    await Promise.all([
        createDefaultMask("S"), createDefaultMask("E"), 
        createDefaultMask("O"), createDefaultMask("C")
    ]);
})();

$("inpImg").onchange = (e) => {
    const f = e.target.files[0]; if(!f) return;
    const img = new Image();
    img.onload = () => { state.srcImg = img; updatePreview(); };
    img.src = URL.createObjectURL(f);
};

window.loadMask = async (key, el) => {
    const f = el.files[0]; if(!f) return;
    const img = new Image();
    img.onload = async () => {
        const whiteImg = await convertToWhiteMask(img);
        state.masks[key] = whiteImg;
        state.maskData[key] = analyzeMask(whiteImg);
        const slot = $("slot"+key);
        slot.innerHTML = "";
        const thumb = img.cloneNode(); 
        slot.appendChild(thumb);
        slot.classList.add("active");
        updatePreview();
    };
    img.src = URL.createObjectURL(f);
};

let isRendering = false;
function updatePreview() {
    if(!state.srcImg || isRendering) return;
    isRendering = true;
    requestAnimationFrame(renderCPU);
}

function renderCPU() {
    const w = 800; 
    const ratio = state.srcImg.height / state.srcImg.width;
    const h = Math.round(w * ratio);
    
    cvs.width = w; cvs.height = h;

    const tmpC = document.createElement("canvas"); tmpC.width = w; tmpC.height = h;
    const tmpCtx = tmpC.getContext("2d");
    tmpCtx.drawImage(state.srcImg, 0, 0, w, h);
    const srcData = tmpCtx.getImageData(0, 0, w, h).data;

    // 투명 배경을 위해 캔버스 초기화
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "white"; // 도형 색상

    const cell = +$("rnCell").value;
    const scaleFactor = w / 1080; 
    const cellSize = cell * scaleFactor;
    
    const uMin = +$("rnMin").value/100;
    const uMax = +$("rnMax").value/100;
    const uCon = +$("rnCon").value/100;
    const uGam = +$("rnGam").value/100;
    const t1=+$("t1").value/100, t2=+$("t2").value/100, t3=+$("t3").value/100;
    const mode = +$("selMode").value;
    const ord = +$("selOrd").value;

    const cols = Math.ceil(w / cellSize);
    const rows = Math.ceil(h / cellSize);

    for(let r = 0; r < rows; r++) {
        for(let c = 0; c < cols; c++) {
            const cx = Math.floor((c + 0.5) * cellSize);
            const cy = Math.floor((r + 0.5) * cellSize);
            if(cx >= w || cy >= h) continue;

            const i = (cy * w + cx) * 4;
            
            // [기능 추가] 투명도 체크 (Alpha < 10 이면 빈 공간)
            const alpha = srcData[i+3];
            if(alpha < 10) continue; 

            let g = (0.299*srcData[i] + 0.587*srcData[i+1] + 0.114*srcData[i+2]) / 255;
            g = Math.pow(Math.max(0, Math.min(1, (g - 0.5) * uCon + 0.5)), 1/uGam);

            let holeScale = uMin + (uMax - uMin) * g;
            if(holeScale <= 0.01) continue; 
            
            const drawSize = cellSize * holeScale;
            const x = c * cellSize + (cellSize - drawSize) / 2;
            const y = r * cellSize + (cellSize - drawSize) / 2;

            if (mode === 0) {
                ctx.fillRect(x, y, drawSize, drawSize);
            } else {
                let k = 'S';
                if (ord === 0) { if(g<t1) k='S'; else if(g<t2) k='E'; else if(g<t3) k='O'; else k='C'; }
                else           { if(g<t1) k='S'; else if(g<t2) k='E'; else if(g<t3) k='C'; else k='O'; }
                
                const maskImg = state.masks[k];
                if(maskImg) {
                    ctx.drawImage(maskImg, x, y, drawSize, drawSize);
                } else {
                    ctx.fillRect(x, y, drawSize, drawSize);
                }
            }
        }
    }
    isRendering = false;
}

// [기능 추가] 모든 조절 항목 입력값 바인딩
bindInput("rnCell", "numCell", updatePreview);
bindInput("rnMin", "numMin", updatePreview);
bindInput("rnMax", "numMax", updatePreview);
bindInput("rnCon", "numCon", updatePreview);
bindInput("rnGam", "numGam", updatePreview);
bindInput("t1", "numT1", updatePreview);
bindInput("t2", "numT2", updatePreview);
bindInput("t3", "numT3", updatePreview);
["selMode", "selOrd"].forEach(k => $(k).oninput = updatePreview);


$("btnSvg").onclick = async () => {
    if(!state.srcImg) return alert("이미지가 없습니다.");
    $("loading").style.display = "flex";
    await new Promise(r => setTimeout(r, 100));

    try {
        const w = 1080; 
        const ratio = state.srcImg.height / state.srcImg.width;
        const h = Math.round(w * ratio);
        
        const tmpC = document.createElement("canvas"); tmpC.width = w; tmpC.height = h;
        const tmpCtx = tmpC.getContext("2d");
        if($("chkFlip").checked) { tmpCtx.translate(0, h); tmpCtx.scale(1, -1); }
        tmpCtx.drawImage(state.srcImg, 0, 0, w, h);
        const srcData = tmpCtx.getImageData(0, 0, w, h).data;
        
        const cell = +$("rnCell").value;
        const uMin = +$("rnMin").value/100;
        const uMax = +$("rnMax").value/100;
        const uCon = +$("rnCon").value/100;
        const uGam = +$("rnGam").value/100;
        const t1=+$("t1").value/100, t2=+$("t2").value/100, t3=+$("t3").value/100;
        const mode = +$("selMode").value;
        const ord = +$("selOrd").value;

        // 배경색 Rect 제거 (투명 배경 지원을 위해)
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
        // svg += `<rect width="${w}" height="${h}" fill="black"/>`; // <-- 삭제됨
        
        // 점(벡터) 색상을 검은색으로 설정 (투명 배경에서 보이도록)
        // 필요시 fill="white"로 변경 가능하지만 하프톤 기본은 흑색
        svg += `<g fill="black">`; 

        const cols = Math.ceil(w / cell);
        const rows = Math.ceil(h / cell);

        const vecCache = {};
        ["S","E","O","C"].forEach(k => vecCache[k] = getFinalOptimizedVector(state.maskData[k]));

        for(let r = 0; r < rows; r++) {
            for(let c = 0; c < cols; c++) {
                const cx = Math.floor((c + 0.5) * cell);
                const cy = Math.floor((r + 0.5) * cell);
                if(cx >= w || cy >= h) continue;

                const i = (cy * w + cx) * 4;
                
                // [기능 추가] 투명도 체크 (SVG 생성 시)
                if(srcData[i+3] < 10) continue;

                let g = (0.299*srcData[i] + 0.587*srcData[i+1] + 0.114*srcData[i+2]) / 255;
                g = Math.pow(Math.max(0, Math.min(1, (g - 0.5) * uCon + 0.5)), 1/uGam);

                let holeScale = uMin + (uMax - uMin) * g;
                if(holeScale <= 0.01) continue;

                const drawSize = cell * holeScale;
                const ox = c * cell + (cell - drawSize) / 2;
                const oy = r * cell + (cell - drawSize) / 2;

                if(mode === 0) {
                    svg += `<rect x="${ox.toFixed(2)}" y="${oy.toFixed(2)}" width="${drawSize.toFixed(2)}" height="${drawSize.toFixed(2)}"/>`;
                } else {
                    let k = 'S';
                    if (ord === 0) { if(g<t1) k='S'; else if(g<t2) k='E'; else if(g<t3) k='O'; else k='C'; }
                    else           { if(g<t1) k='S'; else if(g<t2) k='E'; else if(g<t3) k='C'; else k='O'; }

                    const vecs = vecCache[k];
                    if(vecs && vecs.length > 0) {
                        for(let v of vecs) {
                            const vx = ox + v.x * drawSize;
                            const vy = oy + v.y * drawSize;
                            const vw = v.w * drawSize;
                            const vh = v.h * drawSize;
                            
                            if(vw > 0.01 && vh > 0.01) {
                                svg += `<rect x="${vx.toFixed(2)}" y="${vy.toFixed(2)}" width="${vw.toFixed(2)}" height="${vh.toFixed(2)}"/>`;
                            }
                        }
                    } else {
                        svg += `<rect x="${ox.toFixed(2)}" y="${oy.toFixed(2)}" width="${drawSize.toFixed(2)}" height="${drawSize.toFixed(2)}"/>`;
                    }
                }
            }
        }
        svg += `</g></svg>`;
        
        const blob = new Blob([svg], {type:"image/svg+xml"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob); a.download = `halftone_final_${Date.now()}.svg`;
        document.body.appendChild(a); a.click(); a.remove();

    } catch(e) { alert("Error: " + e); } finally { $("loading").style.display = "none"; }
};

// [v6.4 엔진 유지] Greedy Merging Algorithm
function getFinalOptimizedVector(imgData) {
    if(!imgData) return [];
    const s = imgData.width; 
    const d = imgData.data;
    
    const grid = Array(s).fill(0).map(() => Array(s).fill(0));
    for(let y=0; y<s; y++) {
        for(let x=0; x<s; x++) {
            const a = d[(y*s + x) * 4 + 3];
            if(a > 10) grid[y][x] = 1;
        }
    }

    const rects = [];
    while(true) {
        let maxRect = null;
        let maxArea = 0;

        for(let r=0; r<s; r++) {
            const heights = Array(s).fill(0);
            for(let c=0; c<s; c++) {
                if(grid[r][c] === 0) continue;
                let h = 0;
                while(r-h >= 0 && grid[r-h][c] === 1) h++;
                heights[c] = h;
            }

            const stack = [];
            for(let c=0; c<=s; c++) {
                const h = (c === s ? 0 : heights[c]);
                while(stack.length > 0 && h < heights[stack[stack.length-1]]) {
                    const height = heights[stack.pop()];
                    const width = (stack.length === 0 ? c : c - stack[stack.length-1] - 1);
                    const area = height * width;
                    if(area > maxArea && area > 0) {
                        maxArea = area;
                        maxRect = {x: c-width, y: r-height+1, w: width, h: height};
                    }
                }
                stack.push(c);
            }
        }

        if(!maxRect) break;

        rects.push({x: maxRect.x/s, y: maxRect.y/s, w: maxRect.w/s, h: maxRect.h/s});
        for(let y=maxRect.y; y<maxRect.y+maxRect.h; y++) {
            for(let x=maxRect.x; x<maxRect.x+maxRect.w; x++) {
                grid[y][x] = 0;
            }
        }
    }
    return rects;
}

$("btnPng").onclick = () => {
    cvs.toBlob(b => { const a = document.createElement("a"); a.href=URL.createObjectURL(b); a.download="preview.png"; a.click(); });
};
</script>
</body>
</html>