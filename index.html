<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Halftone Tool - Flip Fix</title>
  <style>
    :root{color-scheme:dark;}
    body{margin:0;font-family:system-ui,-apple-system,sans-serif;background:#0b0b0b;color:#eaeaea;overflow:hidden;}
    .app{display:flex;height:100vh;}
    
    .stage{flex:1;display:flex;align-items:center;justify-content:center;padding:20px;background:#181818;position:relative;}
    canvas#view{background:#ffffff;box-shadow:0 0 40px rgba(0,0,0,0.5);max-width:100%;max-height:100%;object-fit:contain;}
    
    .panel{width:400px;background:#111;border-left:1px solid #222;padding:20px;overflow-y:auto;display:flex;flex-direction:column;gap:16px;}
    
    label{font-size:12px;color:#888;font-weight:600;display:block;margin-bottom:6px;}
    input[type="range"]{width:100%;margin:0;cursor:pointer;}
    select,button,input[type="file"]{width:100%;padding:10px;border-radius:6px;border:1px solid #333;background:#1a1a1a;color:#eee;font-size:13px;}
    button{cursor:pointer;font-weight:bold;transition:background 0.2s;}
    button:hover{background:#2a2a2a;border-color:#555;}
    button.primary{background:#eee;color:#000;}
    
    .row{display:flex;gap:10px;}
    .group{border:1px solid #222;padding:12px;border-radius:8px;background:#141414;}
    .hint{font-size:11px;color:#666;line-height:1.4;margin-top:4px;}
    .status{font-size:11px;color:#aaa;margin-top:4px;}
    .status.ok{color:#4ade80;}
    .status.bad{color:#f87171;}
    
    .mask-uploader {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-top: 8px;
        background: #222;
        padding: 8px;
        border-radius: 8px;
    }
    .mask-btn {
        border: 1px dashed #555;
        border-radius: 6px;
        height: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: #888;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        background: #1a1a1a;
        transition: all 0.2s;
    }
    .mask-btn:hover { background: #333; border-color: #999; color: #fff; }
    .mask-btn input {
        position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer;
    }
    .mask-btn img {
        position: absolute; width: 100%; height: 100%; object-fit: contain;
        opacity: 0.4; pointer-events: none;
    }
    .mask-btn.loaded { border-style: solid; border-color: #4ade80; }
    .mask-btn.loaded span { display: none; }
    .mask-btn.loaded img { opacity: 1; }

    #overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:999;}
    #overlay .spinner{width:40px;height:40px;border:4px solid #333;border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite;margin-bottom:16px;}
    @keyframes spin{to{transform:rotate(360deg);}}
  </style>
</head>
<body>

  <div id="overlay"><div class="spinner"></div><div style="color:white">Processing...</div></div>

  <div class="app">
    <div class="stage">
      <canvas id="view"></canvas>
    </div>

    <div class="panel">
      <div class="group">
        <label>1. ì›ë³¸ ì´ë¯¸ì§€</label>
        <input id="file" type="file" accept="image/*" />
        <label style="margin-top:8px; display:flex; align-items:center; gap:6px; cursor:pointer; color:#eee;">
            <input type="checkbox" id="flipView" checked /> ì´ë¯¸ì§€ê°€ ê±°ê¾¸ë¡œ ë³´ì´ë©´ ì²´í¬ í•´ì œ/ì„¤ì •
        </label>
      </div>

      <div class="group">
        <label>2. í•˜í”„í†¤ ì„¤ì •</label>
        <label>ì…€ í¬ê¸°</label><input id="cell" type="range" min="8" max="100" value="20" />
        <div class="row" style="margin-top:10px;">
          <div><label>Min(%)</label><input id="holeMin" type="range" min="0" max="95" value="10" /></div>
          <div><label>Max(%)</label><input id="holeMax" type="range" min="0" max="95" value="85" /></div>
        </div>
        <div class="row" style="margin-top:10px;">
          <div><label>ëŒ€ë¹„</label><input id="contrast" type="range" min="10" max="300" value="100" /></div>
          <div><label>ê°ë§ˆ</label><input id="gamma" type="range" min="50" max="250" value="100" /></div>
        </div>
      </div>

      <div class="group">
        <label>3. ë§ˆìŠ¤í¬(ì‘ìš©) ì„¤ì •</label>
        <select id="mode">
          <option value="1" selected>ì‘ìš© (S/E/O/C ë§ˆìŠ¤í¬)</option>
          <option value="0">ê¸°ë³¸ (ì‚¬ê°í˜• êµ¬ë©)</option>
        </select>
        
        <div id="modeOptions" style="margin-top:12px;">
            <div class="hint">ğŸ‘‡ ì•„ë˜ ë°•ìŠ¤ë¥¼ ëˆŒëŸ¬ S, E, O, C ì´ë¯¸ì§€ë¥¼ ê°ê° ë„£ì–´ì£¼ì„¸ìš”!</div>
            <div class="mask-uploader">
                <div class="mask-btn" id="btnS">
                    <span>S íŒŒì¼<br>ì—…ë¡œë“œ</span>
                    <input type="file" accept="image/*" onchange="loadUserMask('S', this)" />
                </div>
                <div class="mask-btn" id="btnE">
                    <span>E íŒŒì¼<br>ì—…ë¡œë“œ</span>
                    <input type="file" accept="image/*" onchange="loadUserMask('E', this)" />
                </div>
                <div class="mask-btn" id="btnO">
                    <span>O íŒŒì¼<br>ì—…ë¡œë“œ</span>
                    <input type="file" accept="image/*" onchange="loadUserMask('O', this)" />
                </div>
                <div class="mask-btn" id="btnC">
                    <span>C íŒŒì¼<br>ì—…ë¡œë“œ</span>
                    <input type="file" accept="image/*" onchange="loadUserMask('C', this)" />
                </div>
            </div>
            
            <div class="row" style="margin-top:12px;">
                <div><label>ë°˜ì „ (Invert)</label><select id="invertMask"><option value="0">OFF</option><option value="1">ON</option></select></div>
                <div><label>ìˆœì„œ</label><select id="order"><option value="1">Sâ†’Eâ†’Câ†’O</option><option value="0">Sâ†’Eâ†’Oâ†’C</option></select></div>
            </div>

            <div style="margin-top:10px;">
                <label>í†¤ ë¶„ë°° (T1, T2, T3)</label>
                <div class="row"><input id="t1" type="range" max="100" value="25"/><input id="t2" type="range" max="100" value="50"/><input id="t3" type="range" max="100" value="75"/></div>
            </div>
        </div>
      </div>

      <div class="group">
        <label>4. ì €ì¥ (AI í˜¸í™˜)</label>
        <div class="row">
          <button id="savePNG">PNG ì €ì¥</button>
          <button id="saveSVG" class="primary">SVG ì €ì¥</button>
        </div>
        <div id="exportStatus" class="status"></div>
      </div>
    </div>
  </div>

<script>
const $ = id => document.getElementById(id);
const state = {
    masks: { S:null, E:null, O:null, C:null }, 
    maskRuns: { S:null, E:null, O:null, C:null },
    srcImage: null,
    width: 1080, height: 1080
};

// --- Fallback Text Mask ---
function createFallbackImage(char) {
    const c = document.createElement("canvas");
    c.width = 128; c.height = 128;
    const ctx = c.getContext("2d");
    ctx.fillStyle = "black"; ctx.fillRect(0,0,128,128);
    ctx.fillStyle = "white"; ctx.font = "bold 100px sans-serif";
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(char, 64, 64);
    return c; 
}

["S","E","O","C"].forEach(k => {
    state.masks[k] = createFallbackImage(k);
    state.maskRuns[k] = traceMaskToRuns(state.masks[k], false);
});

// --- Vector Logic ---
function traceMaskToRuns(img, invert) {
    const size = 128;
    const c = document.createElement("canvas");
    c.width = size; c.height = size;
    const ctx = c.getContext("2d");
    ctx.drawImage(img, 0, 0, size, size);
    
    const data = ctx.getImageData(0,0,size,size).data;
    const runs = [];
    const threshold = 128; 

    for(let y=0; y<size; y++) {
        let startX = -1;
        for(let x=0; x<size; x++) {
            const idx = (y*size + x) * 4;
            let val = data[idx];
            if (invert) val = 255 - val;
            
            if (val > threshold) { 
                if (startX === -1) startX = x;
            } else { 
                if (startX !== -1) {
                    runs.push({ x: startX/size, y: 1.0-(y+1)/size, w: (x-startX)/size, h: 1.0/size });
                    startX = -1;
                }
            }
        }
        if (startX !== -1) {
             runs.push({ x: startX/size, y: 1.0-(y+1)/size, w: (size-startX)/size, h: 1.0/size });
        }
    }
    return runs;
}

function updateMaskCache() {
    const inv = $("invertMask").value === "1";
    ["S","E","O","C"].forEach(k => {
        if(state.masks[k]) {
            state.maskRuns[k] = traceMaskToRuns(state.masks[k], inv);
        }
    });
}

// --- WebGL Setup (with Flip Uniform) ---
const canvas = $("view");
const gl = canvas.getContext("webgl", { preserveDrawingBuffer: true });
const vs = `attribute vec2 p;varying vec2 v;void main(){v=(p+1.)*.5;gl_Position=vec4(p,0,1);}`;
const fs = `precision highp float;varying vec2 v;
uniform sampler2D uI,uS,uE,uO,uC;
uniform vec2 uR,uSc,uOff;
uniform float uCell,uMin,uMax,uCon,uGam,uT1,uT2,uT3;
uniform int uMod,uInv,uOrd,uFlip; // uFlip ì¶”ê°€
float getM(int i,vec2 uv){
  if(i==0)return texture2D(uS,uv).r;if(i==1)return texture2D(uE,uv).r;
  if(i==2)return texture2D(uO,uv).r;return texture2D(uC,uv).r;
}
void main(){
  // 1. í™”ë©´ ë°˜ì „ ì²˜ë¦¬
  vec2 uvCoord = v;
  if(uFlip == 1) uvCoord.y = 1.0 - uvCoord.y;

  vec2 uv=(uvCoord-uOff)/uSc;
  if(uv.x<0.||uv.x>1.||uv.y<0.||uv.y>1.){gl_FragColor=vec4(1);return;}
  vec2 cc=(floor(uvCoord*uR/uCell)+.5)*uCell/uR;
  vec3 c=texture2D(uI,(cc-uOff)/uSc).rgb;
  float g=dot(c,vec3(.299,.587,.114));
  g=pow(clamp((g-.5)*uCon+.5,0.,1.),1./uGam);
  float s=mix(uMin,uMax,g);
  float m=0.;
  vec2 loc=fract(uvCoord*uR/uCell);
  if(uMod==0){
    vec2 d=abs(loc-.5)*2.; m=step(max(d.x,d.y),s);
  }else{
    int t=0;
    if(uOrd==0){if(g<uT1)t=0;else if(g<uT2)t=1;else if(g<uT3)t=2;else t=3;}
    else{if(g<uT1)t=0;else if(g<uT2)t=1;else if(g<uT3)t=3;else t=2;}
    vec2 suv=(loc-.5)/max(.01,s)+.5;
    if(suv.x>=0.&&suv.x<=1.&&suv.y>=0.&&suv.y<=1.) m=step(.5, uInv==1?1.-getM(t,suv):getM(t,suv));
  }
  gl_FragColor=vec4(vec3(1.-m),1);
}`;

function sh(t,s){const x=gl.createShader(t);gl.shaderSource(x,s);gl.compileShader(x);return x;}
const p=gl.createProgram();gl.attachShader(p,sh(35633,vs));gl.attachShader(p,sh(35632,fs));gl.linkProgram(p);gl.useProgram(p);
gl.bindBuffer(34962,gl.createBuffer());gl.bufferData(34962,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),35044);
gl.enableVertexAttribArray(0);gl.vertexAttribPointer(0,2,5126,0,0,0);

const textures=[];
[0,1,2,3,4].forEach(i=>{
    const t=gl.createTexture();gl.activeTexture(33984+i);gl.bindTexture(3553,t);
    gl.texParameteri(3553,10242,33071);gl.texParameteri(3553,10243,33071);
    gl.texParameteri(3553,10241,9729);gl.texParameteri(3553,10240,9729);
    gl.texImage2D(3553,0,6408,1,1,0,6408,5121,new Uint8Array([255,255,255,255]));
    textures.push(t);
    gl.uniform1i(gl.getUniformLocation(p,["uI","uS","uE","uO","uC"][i]),i);
});

const locs={};
["uR","uSc","uOff","uCell","uMin","uMax","uCon","uGam","uT1","uT2","uT3","uMod","uInv","uOrd","uFlip"].forEach(k=>locs[k]=gl.getUniformLocation(p,k));

function render(){
    if(!state.srcImage){ gl.clearColor(1,1,1,1);gl.clear(16384);return;}
    const w=state.width,h=state.height;
    canvas.width=w; canvas.height=h; gl.viewport(0,0,w,h);
    
    const sw=state.srcImage.width, sh=state.srcImage.height;
    const ir=sw/sh, cr=w/h;
    let sx=1,sy=1,ox=0,oy=0;
    if(ir>cr){ sy=(w/ir)/h; oy=(1-sy)/2; }else{ sx=(h*ir)/w; ox=(1-sx)/2; }
    
    gl.uniform2f(locs.uR,w,h);gl.uniform2f(locs.uSc,sx,sy);gl.uniform2f(locs.uOff,ox,oy);
    gl.uniform1f(locs.uCell,$("cell").value);
    gl.uniform1f(locs.uMin,$("holeMin").value/100);gl.uniform1f(locs.uMax,$("holeMax").value/100);
    gl.uniform1f(locs.uCon,$("contrast").value/100);gl.uniform1f(locs.uGam,$("gamma").value/100);
    gl.uniform1f(locs.uT1,$("t1").value/100);gl.uniform1f(locs.uT2,$("t2").value/100);gl.uniform1f(locs.uT3,$("t3").value/100);
    gl.uniform1i(locs.uMod,$("mode").value);gl.uniform1i(locs.uInv,$("invertMask").value);
    gl.uniform1i(locs.uOrd,$("order").value);
    
    // ì²´í¬ë°•ìŠ¤ ê°’ ì „ë‹¬ (ì²´í¬ë˜ë©´ 1 -> ì…°ì´ë”ì—ì„œ ë’¤ì§‘ìŒ)
    gl.uniform1i(locs.uFlip, $("flipView").checked ? 1 : 0);
    
    gl.drawArrays(4,0,6);
}

// User Mask Load
async function loadUserMask(key, input) {
    const f = input.files[0];
    if(!f) return;
    const bmp = await createImageBitmap(f);
    
    const btn = document.getElementById("btn" + key);
    const oldImg = btn.querySelector("img");
    if(oldImg) oldImg.remove();
    const thumb = document.createElement("img");
    thumb.src = URL.createObjectURL(f);
    btn.appendChild(thumb);
    btn.classList.add("loaded");

    state.masks[key] = bmp;
    gl.activeTexture(33984 + (key==='S'?1:key==='E'?2:key==='O'?3:4));
    gl.bindTexture(3553, textures[key==='S'?1:key==='E'?2:key==='O'?3:4]);
    gl.texImage2D(3553, 0, 6408, 6408, 5121, bmp);
    gl.generateMipmap(3553);

    updateMaskCache();
    render();
}

$("file").onchange=async e=>{
    if(!e.target.files[0])return;
    state.srcImage=await createImageBitmap(e.target.files[0]);
    gl.activeTexture(33984);gl.bindTexture(3553,textures[0]);
    // í”½ì…€ ìŠ¤í† ì–´(ë’¤ì§‘ê¸° ì˜µì…˜) ì œê±°í•¨ - ì…°ì´ë” uFlipìœ¼ë¡œ ì œì–´
    gl.texImage2D(3553,0,6408,6408,5121,state.srcImage);
    gl.generateMipmap(3553);
    render();
};

["cell","holeMin","holeMax","contrast","gamma","t1","t2","t3","order"].forEach(k=>$(k).oninput=render);
$("mode").onchange=render;
$("invertMask").onchange=()=>{ updateMaskCache(); render(); };
$("flipView").onchange=render; // ë°˜ì „ í† ê¸€ ì‹œ ë Œë”ë§

// --- Export Logic ---
$("saveSVG").onclick=async()=>{
    if(!state.srcImage)return alert("ì´ë¯¸ì§€ ë¨¼ì €!");
    $("overlay").style.display="flex"; await new Promise(r=>setTimeout(r,50));
    try {
        const w=state.width, h=state.height, cell=+$("cell").value;
        const cInv=document.createElement("canvas"); cInv.width=w; cInv.height=h;
        const ctx=cInv.getContext("2d");
        const sw=state.srcImage.width, sh=state.srcImage.height;
        const ir=sw/sh, cr=w/h;
        let dw,dh,dx,dy;
        if(ir>cr){dw=w;dh=w/ir;dx=0;dy=(h-dh)/2;}else{dh=h;dw=h*ir;dy=0;dx=(w-dw)/2;}
        
        ctx.fillStyle="white";ctx.fillRect(0,0,w,h);
        ctx.drawImage(state.srcImage,dx,dy,dw,dh);
        const pix=ctx.getImageData(0,0,w,h).data;
        
        let svg=`<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg"><rect width="${w}" height="${h}" fill="black"/><g fill="white">`;
        const cols=Math.ceil(w/cell), rows=Math.ceil(h/cell);
        const uMin=+$("holeMin").value/100, uMax=+$("holeMax").value/100;
        const uCon=+$("contrast").value/100, uGam=+$("gamma").value/100;
        const t1=+$("t1").value/100, t2=+$("t2").value/100, t3=+$("t3").value/100;
        const mode=+$("mode").value, ord=+$("order").value;
        
        for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
                const cx=(c+.5)*cell, cy=(r+.5)*cell;
                if(cx<dx||cx>dx+dw||cy<dy||cy>dy+dh){
                    svg+=`<rect x="${c*cell}" y="${r*cell}" width="${cell}" height="${cell}"/>`; continue;
                }
                const pIdx=(Math.floor(cy)*w+Math.floor(cx))*4;
                let g=(.299*pix[pIdx]+.587*pix[pIdx+1]+.114*pix[pIdx+2])/255;
                g=Math.pow(Math.max(0,Math.min(1,(g-.5)*uCon+.5)),1./uGam);
                let size=uMin+(uMax-uMin)*g;
                if(size<=0.01)continue;
                if(size>=0.99){ svg+=`<rect x="${c*cell}" y="${r*cell}" width="${cell}" height="${cell}"/>`; continue;}
                const fSize=cell*size, off=(cell-fSize)/2;
                const ox=c*cell+off, oy=r*cell+off;
                
                if(mode==0){
                    svg+=`<rect x="${ox}" y="${oy}" width="${fSize}" height="${fSize}"/>`;
                }else{
                    let ch='S';
                    if(ord==0){ if(g<t1)ch='S';else if(g<t2)ch='E';else if(g<t3)ch='O';else ch='C'; }
                    else{ if(g<t1)ch='S';else if(g<t2)ch='E';else if(g<t3)ch='C';else ch='O'; }
                    const runs = state.maskRuns[ch];
                    if(!runs || runs.length===0){
                        svg+=`<rect x="${ox}" y="${oy}" width="${fSize}" height="${fSize}"/>`;
                    }else{
                        for(const run of runs){
                            const rx=ox+run.x*fSize, ry=oy+(1.-(run.y+run.h))*fSize;
                            const rw=run.w*fSize, rh=run.h*fSize;
                            if(rw>.1&&rh>.1) svg+=`<rect x="${rx.toFixed(2)}" y="${ry.toFixed(2)}" width="${rw.toFixed(2)}" height="${rh.toFixed(2)}"/>`;
                        }
                    }
                }
            }
        }
        svg+=`</g></svg>`;
        const url=URL.createObjectURL(new Blob([svg],{type:"image/svg+xml"}));
        const a=document.createElement("a");a.href=url;a.download=`halftone_${Date.now()}.svg`;
        document.body.appendChild(a);a.click();a.remove();
        $("exportStatus").innerHTML=`<span class="ok">ì™„ë£Œ!</span>`;
    }catch(e){
        alert(e);$("exportStatus").innerHTML=`<span class="bad">ì—ëŸ¬</span>`;
    }finally{
        $("overlay").style.display="none";
    }
};
</script>
</body>
</html>